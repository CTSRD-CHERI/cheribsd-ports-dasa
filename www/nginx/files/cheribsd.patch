diff --git auto/os/conf auto/os/conf
index 7c6cb691..d7f6e038 100644
--- auto/os/conf
+++ auto/os/conf
@@ -110,7 +110,7 @@ case "$NGX_MACHINE" in
         NGX_MACH_CACHE_LINE=64
     ;;
 
-    aarch64 )
+    aarch64 | arm64)
         have=NGX_ALIGNMENT value=16 . auto/define
         NGX_MACH_CACHE_LINE=64
     ;;
diff --git auto/types/sizeof auto/types/sizeof
index 480d8cfa..5ee68952 100644
--- auto/types/sizeof
+++ auto/types/sizeof
@@ -56,6 +56,11 @@ case $ngx_size in
         ngx_max_len='(sizeof("-9223372036854775808") - 1)'
     ;;
 
+    16)
+        ngx_max_value=9223372036854775807LL
+        ngx_max_len='(sizeof("-9223372036854775808") - 1)'
+    ;;
+
     *)
         echo
         echo "$0: error: can not detect $ngx_type size"
diff --git conf/nginx.conf conf/nginx.conf
index 29bc085f..0c867852 100644
--- conf/nginx.conf
+++ conf/nginx.conf
@@ -32,6 +32,9 @@ http {
 
     #gzip  on;
 
+    types_hash_bucket_size 128;
+    variables_hash_bucket_size 128;
+
     server {
         listen       80;
         server_name  localhost;
diff --git src/core/ngx_array.c src/core/ngx_array.c
index 4ea226f0..dae4b869 100644
--- src/core/ngx_array.c
+++ src/core/ngx_array.c
@@ -59,6 +59,18 @@ ngx_array_push(ngx_array_t *a)
 
         p = a->pool;
 
+#if defined(__CHERI_PURE_CAPABILITY__)
+	/* allocate a new array */
+
+	new = ngx_palloc(p, 2 * size);
+	if (new == NULL) {
+	return NULL;
+	}
+
+	ngx_memcpy(new, a->elts, size);
+	a->elts = new;
+	a->nalloc *= 2;
+#else
         if ((u_char *) a->elts + size == p->d.last
             && p->d.last + a->size <= p->d.end)
         {
@@ -82,6 +94,7 @@ ngx_array_push(ngx_array_t *a)
             a->elts = new;
             a->nalloc *= 2;
         }
+#endif
     }
 
     elt = (u_char *) a->elts + a->size * a->nelts;
diff --git src/core/ngx_config.h src/core/ngx_config.h
index 1861be60..dab593c2 100644
--- src/core/ngx_config.h
+++ src/core/ngx_config.h
@@ -43,6 +43,10 @@
 
 #endif
 
+#ifndef __has_builtin
+#define __has_builtin(x) 0
+#endif
+
 
 #ifndef NGX_HAVE_SO_SNDLOWAT
 #define NGX_HAVE_SO_SNDLOWAT     1
@@ -79,6 +83,12 @@ typedef intptr_t        ngx_int_t;
 typedef uintptr_t       ngx_uint_t;
 typedef intptr_t        ngx_flag_t;
 
+#ifdef _PTRADDR_T_DECLARED
+typedef ptraddr_t	ngx_ptraddr_t;
+#else
+typedef uintptr_t	ngx_ptraddr_t;
+#endif
+
 
 #define NGX_INT32_LEN   (sizeof("-2147483648") - 1)
 #define NGX_INT64_LEN   (sizeof("-9223372036854775808") - 1)
@@ -97,9 +107,14 @@ typedef intptr_t        ngx_flag_t;
 #define NGX_ALIGNMENT   sizeof(unsigned long)    /* platform word */
 #endif
 
+#if __has_builtin(__builtin_align_up)
+#define ngx_align(d, a)     __builtin_align_up(d, a)
+#define ngx_align_ptr(p, a) __builtin_align_up(p, a)
+#else
 #define ngx_align(d, a)     (((d) + (a - 1)) & ~(a - 1))
 #define ngx_align_ptr(p, a)                                                   \
     (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) & ~((uintptr_t) a - 1))
+#endif
 
 
 #define ngx_abort       abort
@@ -141,5 +156,12 @@ typedef intptr_t        ngx_flag_t;
 
 #endif
 
+/* XXXAR: For the low pointer bits macros */
+#if __has_include(<cheri/cheric.h>)
+#include <cheri/cheric.h>
+#else
+#include <cheri.h>
+#endif
+
 
 #endif /* _NGX_CONFIG_H_INCLUDED_ */
diff --git src/core/ngx_crc32.c src/core/ngx_crc32.c
index a5b4017b..ff66ffdf 100644
--- src/core/ngx_crc32.c
+++ src/core/ngx_crc32.c
@@ -107,9 +107,7 @@ ngx_crc32_table_init(void)
 {
     void  *p;
 
-    if (((uintptr_t) ngx_crc32_table_short
-          & ~((uintptr_t) ngx_cacheline_size - 1))
-        == (uintptr_t) ngx_crc32_table_short)
+    if (__builtin_is_aligned(ngx_crc32_table_short, ngx_cacheline_size))
     {
         return NGX_OK;
     }
diff --git src/core/ngx_hash.c src/core/ngx_hash.c
index 8215c271..4ba10df4 100644
--- src/core/ngx_hash.c
+++ src/core/ngx_hash.c
@@ -97,23 +97,21 @@ ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
          *     11 - value is pointer to wildcard hash allowing
          *          "*.example.com" only.
          */
-
-        if ((uintptr_t) value & 2) {
+        if (cheri_get_low_ptr_bits((uintptr_t) value, 2)) {
 
             if (n == 0) {
 
                 /* "example.com" */
 
-                if ((uintptr_t) value & 1) {
+                if (cheri_get_low_ptr_bits((uintptr_t) value, 1)) {
                     return NULL;
                 }
 
-                hwc = (ngx_hash_wildcard_t *)
-                                          ((uintptr_t) value & (uintptr_t) ~3);
+                hwc = (ngx_hash_wildcard_t *)cheri_clear_low_ptr_bits((uintptr_t)value, 3);
                 return hwc->value;
             }
 
-            hwc = (ngx_hash_wildcard_t *) ((uintptr_t) value & (uintptr_t) ~3);
+            hwc = (ngx_hash_wildcard_t *) cheri_clear_low_ptr_bits((uintptr_t)value, 3);
 
             value = ngx_hash_find_wc_head(hwc, name, n - 1);
 
@@ -124,7 +122,7 @@ ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
             return hwc->value;
         }
 
-        if ((uintptr_t) value & 1) {
+        if (cheri_get_low_ptr_bits((uintptr_t) value, 1)) {
 
             if (n == 0) {
 
@@ -133,7 +131,7 @@ ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
                 return NULL;
             }
 
-            return (void *) ((uintptr_t) value & (uintptr_t) ~3);
+            return (void *) cheri_clear_low_ptr_bits((uintptr_t)value, 3);
         }
 
         return value;
@@ -185,11 +183,11 @@ ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
          *     11 - value is pointer to wildcard hash allowing "example.*".
          */
 
-        if ((uintptr_t) value & 2) {
+        if (cheri_get_low_ptr_bits((uintptr_t) value, 2)) {
 
             i++;
 
-            hwc = (ngx_hash_wildcard_t *) ((uintptr_t) value & (uintptr_t) ~3);
+            hwc = (ngx_hash_wildcard_t *) cheri_clear_low_ptr_bits((uintptr_t)value, 3);
 
             value = ngx_hash_find_wc_tail(hwc, &name[i], len - i);
 
diff --git src/core/ngx_palloc.c src/core/ngx_palloc.c
index d3044ac9..4b9578f3 100644
--- src/core/ngx_palloc.c
+++ src/core/ngx_palloc.c
@@ -20,6 +20,12 @@ ngx_create_pool(size_t size, ngx_log_t *log)
 {
     ngx_pool_t  *p;
 
+    if (size < sizeof(ngx_pool_t))
+        size = sizeof(ngx_pool_t);
+#ifdef __CHERI_PURE_CAPABILITY__
+    size = __builtin_cheri_round_representable_length(size);
+#endif
+
     p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);
     if (p == NULL) {
         return NULL;
@@ -160,9 +166,15 @@ ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)
             m = ngx_align_ptr(m, NGX_ALIGNMENT);
         }
 
-        if ((size_t) (p->d.end - m) >= size) {
+        // Alignment can overflow buffer, need to use a signed type
+        if ((ssize_t) (p->d.end - m) >= (ssize_t) size) {
             p->d.last = m + size;
 
+#ifdef __CHERI_PURE_CAPABILITY__
+            // This is safe so long as NGX_MAX_ALLOC_FROM_POOL is
+            // representable.  By default it's 4095 so safe.
+            m = cheri_setboundsexact(m, size);
+#endif
             return m;
         }
 
@@ -206,6 +218,9 @@ ngx_palloc_block(ngx_pool_t *pool, size_t size)
 
     p->d.next = new;
 
+#ifdef __CHERI_PURE_CAPABILITY__
+    m = cheri_setboundsexact(m, size);
+#endif
     return m;
 }
 
diff --git src/core/ngx_palloc.h src/core/ngx_palloc.h
index 376e0128..e9403076 100644
--- src/core/ngx_palloc.h
+++ src/core/ngx_palloc.h
@@ -76,10 +76,10 @@ ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);
 void ngx_destroy_pool(ngx_pool_t *pool);
 void ngx_reset_pool(ngx_pool_t *pool);
 
-void *ngx_palloc(ngx_pool_t *pool, size_t size);
-void *ngx_pnalloc(ngx_pool_t *pool, size_t size);
-void *ngx_pcalloc(ngx_pool_t *pool, size_t size);
-void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment);
+void *ngx_palloc(ngx_pool_t *pool, size_t size) __attribute__((alloc_size(2)));
+void *ngx_pnalloc(ngx_pool_t *pool, size_t size) __attribute__((alloc_size(2)));
+void *ngx_pcalloc(ngx_pool_t *pool, size_t size) __attribute__((alloc_size(2)));
+void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment) __attribute__((alloc_size(2)));
 ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);
 
 
diff --git src/core/ngx_slab.c src/core/ngx_slab.c
index b8577ce7..5836a67b 100644
--- src/core/ngx_slab.c
+++ src/core/ngx_slab.c
@@ -44,10 +44,10 @@
 #define ngx_slab_slots(pool)                                                  \
     (ngx_slab_page_t *) ((u_char *) (pool) + sizeof(ngx_slab_pool_t))
 
-#define ngx_slab_page_type(page)   ((page)->prev & NGX_SLAB_PAGE_MASK)
+#define ngx_slab_page_type(page)   cheri_get_low_ptr_bits((page)->prev, NGX_SLAB_PAGE_MASK)
 
 #define ngx_slab_page_prev(page)                                              \
-    (ngx_slab_page_t *) ((page)->prev & ~NGX_SLAB_PAGE_MASK)
+    (ngx_slab_page_t *) cheri_clear_low_ptr_bits((page)->prev, NGX_SLAB_PAGE_MASK)
 
 #define ngx_slab_page_addr(pool, page)                                        \
     ((((page) - (pool)->pages) << ngx_pagesize_shift)                         \
@@ -184,8 +184,9 @@ void *
 ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 {
     size_t            s;
-    uintptr_t         p, m, mask, *bitmap;
-    ngx_uint_t        i, n, slot, shift, map;
+    uintptr_t         p;
+    ptraddr_t           m, mask, *bitmap, n;
+    ngx_uint_t        i, slot, shift, map;
     ngx_slab_page_t  *page, *prev, *slots;
 
     if (size > ngx_slab_max_size) {
@@ -227,7 +228,7 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 
         if (shift < ngx_slab_exact_shift) {
 
-            bitmap = (uintptr_t *) ngx_slab_page_addr(pool, page);
+            bitmap = (ptraddr_t *) ngx_slab_page_addr(pool, page);
 
             map = (ngx_pagesize >> shift) / (8 * sizeof(uintptr_t));
 
@@ -295,10 +296,10 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 
         } else { /* shift > ngx_slab_exact_shift */
 
-            mask = ((uintptr_t) 1 << (ngx_pagesize >> shift)) - 1;
+            mask = ((ptraddr_t) 1 << (ngx_pagesize >> shift)) - 1;
             mask <<= NGX_SLAB_MAP_SHIFT;
 
-            for (m = (uintptr_t) 1 << NGX_SLAB_MAP_SHIFT, i = 0;
+            for (m = (ptraddr_t) 1 << NGX_SLAB_MAP_SHIFT, i = 0;
                  m & mask;
                  m <<= 1, i++)
             {
@@ -333,7 +334,7 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 
     if (page) {
         if (shift < ngx_slab_exact_shift) {
-            bitmap = (uintptr_t *) ngx_slab_page_addr(pool, page);
+            bitmap = (ptraddr_t *) ngx_slab_page_addr(pool, page);
 
             n = (ngx_pagesize >> shift) / ((1 << shift) * 8);
 
@@ -347,7 +348,7 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
                 bitmap[i] = NGX_SLAB_BUSY;
             }
 
-            m = ((uintptr_t) 1 << ((n + 1) % (8 * sizeof(uintptr_t)))) - 1;
+            m = ((ptraddr_t) 1 << ((n + 1) % (8 * sizeof(uintptr_t)))) - 1;
             bitmap[i] = m;
 
             map = (ngx_pagesize >> shift) / (8 * sizeof(uintptr_t));
@@ -388,7 +389,7 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 
         } else { /* shift > ngx_slab_exact_shift */
 
-            page->slab = ((uintptr_t) 1 << NGX_SLAB_MAP_SHIFT) | shift;
+            page->slab = ((ptraddr_t) 1 << NGX_SLAB_MAP_SHIFT) | shift;
             page->next = &slots[slot];
             page->prev = (uintptr_t) &slots[slot] | NGX_SLAB_BIG;
 
@@ -461,7 +462,7 @@ void
 ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
 {
     size_t            size;
-    uintptr_t         slab, m, *bitmap;
+    ptraddr_t           slab, m, *bitmap;
     ngx_uint_t        i, n, type, slot, shift, map;
     ngx_slab_page_t  *slots, *page;
 
@@ -484,15 +485,14 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
         shift = slab & NGX_SLAB_SHIFT_MASK;
         size = (size_t) 1 << shift;
 
-        if ((uintptr_t) p & (size - 1)) {
+        if ((ptraddr_t) p & (size - 1)) {
             goto wrong_chunk;
         }
 
-        n = ((uintptr_t) p & (ngx_pagesize - 1)) >> shift;
-        m = (uintptr_t) 1 << (n % (8 * sizeof(uintptr_t)));
-        n /= 8 * sizeof(uintptr_t);
-        bitmap = (uintptr_t *)
-                             ((uintptr_t) p & ~((uintptr_t) ngx_pagesize - 1));
+        n = ((ptraddr_t) p & (ngx_pagesize - 1)) >> shift;
+        m = (ptraddr_t) 1 << (n % (sizeof(uintptr_t) * 8));
+        n /= sizeof(uintptr_t) * 8;
+        bitmap = (ptraddr_t *)__builtin_align_down(p, ngx_pagesize);
 
         if (bitmap[n] & m) {
             slot = shift - pool->min_shift;
@@ -516,7 +516,7 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
             }
 
             i = n / (8 * sizeof(uintptr_t));
-            m = ((uintptr_t) 1 << (n % (8 * sizeof(uintptr_t)))) - 1;
+            m = ((ptraddr_t) 1 << (n % (8 * sizeof(uintptr_t)))) - 1;
 
             if (bitmap[i] & ~m) {
                 goto done;
@@ -541,11 +541,11 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
 
     case NGX_SLAB_EXACT:
 
-        m = (uintptr_t) 1 <<
-                (((uintptr_t) p & (ngx_pagesize - 1)) >> ngx_slab_exact_shift);
+        m = (ptraddr_t) 1 <<
+                (((ptraddr_t) p & (ngx_pagesize - 1)) >> ngx_slab_exact_shift);
         size = ngx_slab_exact_size;
 
-        if ((uintptr_t) p & (size - 1)) {
+        if ((ptraddr_t) p & (size - 1)) {
             goto wrong_chunk;
         }
 
@@ -582,11 +582,11 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
         shift = slab & NGX_SLAB_SHIFT_MASK;
         size = (size_t) 1 << shift;
 
-        if ((uintptr_t) p & (size - 1)) {
+        if ((ptraddr_t) p & (size - 1)) {
             goto wrong_chunk;
         }
 
-        m = (uintptr_t) 1 << ((((uintptr_t) p & (ngx_pagesize - 1)) >> shift)
+        m = (ptraddr_t) 1 << ((((ptraddr_t) p & (ngx_pagesize - 1)) >> shift)
                               + NGX_SLAB_MAP_SHIFT);
 
         if (slab & m) {
@@ -619,7 +619,7 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
 
     case NGX_SLAB_PAGE:
 
-        if ((uintptr_t) p & (ngx_pagesize - 1)) {
+        if ((ptraddr_t) p & (ngx_pagesize - 1)) {
             goto wrong_chunk;
         }
 
diff --git src/core/ngx_slab.h src/core/ngx_slab.h
index d1876bbe..21114c4a 100644
--- src/core/ngx_slab.h
+++ src/core/ngx_slab.h
@@ -16,7 +16,7 @@
 typedef struct ngx_slab_page_s  ngx_slab_page_t;
 
 struct ngx_slab_page_s {
-    uintptr_t         slab;
+    vaddr_t           slab;
     ngx_slab_page_t  *next;
     uintptr_t         prev;
 };
diff --git src/event/modules/ngx_kqueue_module.c src/event/modules/ngx_kqueue_module.c
index 9c7244c4..c139864a 100644
--- src/event/modules/ngx_kqueue_module.c
+++ src/event/modules/ngx_kqueue_module.c
@@ -345,8 +345,8 @@ ngx_kqueue_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
     ev->disabled = 0;
 
     if (ev->index < nchanges
-        && ((uintptr_t) change_list[ev->index].udata & (uintptr_t) ~1)
-            == (uintptr_t) ev)
+        && (cheri_clear_low_ptr_bits((uintptr_t) change_list[ev->index].udata, 1)
+            == (uintptr_t) ev))
     {
         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                        "kevent deleted: %d: ft:%i",
@@ -358,7 +358,7 @@ ngx_kqueue_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
 
         if (ev->index < nchanges) {
             e = (ngx_event_t *)
-                    ((uintptr_t) change_list[nchanges].udata & (uintptr_t) ~1);
+                    cheri_clear_low_ptr_bits((uintptr_t) change_list[nchanges].udata, 1);
             change_list[ev->index] = change_list[nchanges];
             e->index = ev->index;
         }
@@ -600,8 +600,8 @@ ngx_kqueue_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
         case EVFILT_READ:
         case EVFILT_WRITE:
 
-            instance = (uintptr_t) ev & 1;
-            ev = (ngx_event_t *) ((uintptr_t) ev & (uintptr_t) ~1);
+            instance = cheri_get_low_ptr_bits((uintptr_t) ev, 1);
+            ev = (ngx_event_t *) cheri_clear_low_ptr_bits((uintptr_t) ev, 1);
 
             if (ev->closed || ev->instance != instance) {
 
diff --git src/http/modules/ngx_http_log_module.c src/http/modules/ngx_http_log_module.c
index f7c4bd2f..82717775 100644
--- src/http/modules/ngx_http_log_module.c
+++ src/http/modules/ngx_http_log_module.c
@@ -773,11 +773,11 @@ static u_char *
 ngx_http_log_copy_short(ngx_http_request_t *r, u_char *buf,
     ngx_http_log_op_t *op)
 {
-    size_t     len;
-    uintptr_t  data;
+    size_t      len;
+    ngx_ptraddr_t data;
 
     len = op->len;
-    data = op->data;
+    data = (ngx_ptraddr_t) op->data;
 
     while (len--) {
         *buf++ = (u_char) (data & 0xff);
@@ -1722,7 +1722,7 @@ ngx_http_log_compile_format(ngx_conf_t *cf, ngx_array_t *flushes,
                 op->len = len;
                 op->getlen = NULL;
 
-                if (len <= sizeof(uintptr_t)) {
+                if (len <= sizeof(ngx_ptraddr_t)) {
                     op->run = ngx_http_log_copy_short;
                     op->data = 0;
 
diff --git src/http/modules/ngx_http_upstream_hash_module.c src/http/modules/ngx_http_upstream_hash_module.c
index e741eb23..141a9bae 100644
--- src/http/modules/ngx_http_upstream_hash_module.c
+++ src/http/modules/ngx_http_upstream_hash_module.c
@@ -169,7 +169,7 @@ ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc, void *data)
     size_t                        size;
     uint32_t                      hash;
     ngx_int_t                     w;
-    uintptr_t                     m;
+    ptraddr_t                     m;
     ngx_uint_t                    n, p;
     ngx_http_upstream_rr_peer_t  *peer;
 
@@ -222,7 +222,7 @@ ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc, void *data)
         }
 
         n = p / (8 * sizeof(uintptr_t));
-        m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+        m = (ptraddr_t) 1 << p % (8 * sizeof(uintptr_t));
 
         if (hp->rrp.tried[n] & m) {
             goto next;
@@ -495,7 +495,7 @@ ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc, void *data)
     ngx_http_upstream_hash_peer_data_t  *hp = data;
 
     time_t                              now;
-    intptr_t                            m;
+    ptraddr_t                           m;
     ngx_str_t                          *server;
     ngx_int_t                           total;
     ngx_uint_t                          i, n, best_i;
@@ -539,7 +539,7 @@ ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc, void *data)
              peer = peer->next, i++)
         {
             n = i / (8 * sizeof(uintptr_t));
-            m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));
+            m = (ptraddr_t) 1 << i % (8 * sizeof(uintptr_t));
 
             if (hp->rrp.tried[n] & m) {
                 continue;
@@ -611,7 +611,7 @@ found:
     ngx_http_upstream_rr_peers_unlock(hp->rrp.peers);
 
     n = best_i / (8 * sizeof(uintptr_t));
-    m = (uintptr_t) 1 << best_i % (8 * sizeof(uintptr_t));
+    m = (ptraddr_t) 1 << best_i % (8 * sizeof(uintptr_t));
 
     hp->rrp.tried[n] |= m;
 
diff --git src/http/modules/ngx_http_upstream_ip_hash_module.c src/http/modules/ngx_http_upstream_ip_hash_module.c
index 1fa01d95..996f543f 100644
--- src/http/modules/ngx_http_upstream_ip_hash_module.c
+++ src/http/modules/ngx_http_upstream_ip_hash_module.c
@@ -152,7 +152,7 @@ ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc, void *data)
 
     time_t                        now;
     ngx_int_t                     w;
-    uintptr_t                     m;
+    ptraddr_t                     m;
     ngx_uint_t                    i, n, p, hash;
     ngx_http_upstream_rr_peer_t  *peer;
 
@@ -192,7 +192,7 @@ ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc, void *data)
         }
 
         n = p / (8 * sizeof(uintptr_t));
-        m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+        m = (ptraddr_t) 1 << p % (8 * sizeof(uintptr_t));
 
         if (iphp->rrp.tried[n] & m) {
             goto next;
diff --git src/http/modules/ngx_http_upstream_least_conn_module.c src/http/modules/ngx_http_upstream_least_conn_module.c
index ebe06276..82dcc492 100644
--- src/http/modules/ngx_http_upstream_least_conn_module.c
+++ src/http/modules/ngx_http_upstream_least_conn_module.c
@@ -102,7 +102,7 @@ ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
     ngx_http_upstream_rr_peer_data_t  *rrp = data;
 
     time_t                         now;
-    uintptr_t                      m;
+    ptraddr_t                      m;
     ngx_int_t                      rc, total;
     ngx_uint_t                     i, n, p, many;
     ngx_http_upstream_rr_peer_t   *peer, *best;
@@ -137,7 +137,7 @@ ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
          peer = peer->next, i++)
     {
         n = i / (8 * sizeof(uintptr_t));
-        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));
+        m = (ptraddr_t) 1 << i % (8 * sizeof(uintptr_t));
 
         if (rrp->tried[n] & m) {
             continue;
@@ -192,7 +192,7 @@ ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
              peer = peer->next, i++)
         {
             n = i / (8 * sizeof(uintptr_t));
-            m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));
+            m = (ptraddr_t) 1 << i % (8 * sizeof(uintptr_t));
 
             if (rrp->tried[n] & m) {
                 continue;
@@ -246,7 +246,7 @@ ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
     rrp->current = best;
 
     n = p / (8 * sizeof(uintptr_t));
-    m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+    m = (ptraddr_t) 1 << p % (8 * sizeof(uintptr_t));
 
     rrp->tried[n] |= m;
 
diff --git src/http/ngx_http_huff_encode.c src/http/ngx_http_huff_encode.c
index c03b153d..88e0d16f 100644
--- src/http/ngx_http_huff_encode.c
+++ src/http/ngx_http_huff_encode.c
@@ -156,7 +156,7 @@ static ngx_http_huff_encode_code_t  ngx_http_huff_encode_table_lc[256] =
 };
 
 
-#if (NGX_PTR_SIZE == 8)
+#if ((defined(__SIZEOF_SIZE_T__) && __SIZEOF_SIZE_T__ == 8) || (!defined(__SIZEOF_SIZE_T__) && NGX_PTR_SIZE == 8))
 
 #if (NGX_HAVE_LITTLE_ENDIAN)
 
diff --git src/http/ngx_http_script.c src/http/ngx_http_script.c
index bebdbd92..23bc0fab 100644
--- src/http/ngx_http_script.c
+++ src/http/ngx_http_script.c
@@ -878,7 +878,7 @@ ngx_http_script_copy_code(ngx_http_script_engine_t *e)
     }
 
     e->ip += sizeof(ngx_http_script_copy_code_t)
-          + ((code->len + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));
+          + __builtin_align_up(code->len, sizeof(uintptr_t));
 
     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                    "http script copy: \"%*s\"", e->pos - p, p);
diff --git src/http/ngx_http_upstream_round_robin.c src/http/ngx_http_upstream_round_robin.c
index 1f15fae5..1a67442b 100644
--- src/http/ngx_http_upstream_round_robin.c
+++ src/http/ngx_http_upstream_round_robin.c
@@ -282,7 +282,8 @@ ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r,
     }
 
     if (n <= 8 * sizeof(uintptr_t)) {
-        rrp->tried = &rrp->data;
+        // FIXME: this is probably wrong
+        rrp->tried = (ptraddr_t*)&rrp->data;
         rrp->data = 0;
 
     } else {
@@ -402,7 +403,8 @@ ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,
     rrp->config = 0;
 
     if (rrp->peers->number <= 8 * sizeof(uintptr_t)) {
-        rrp->tried = &rrp->data;
+        // FIXME: this is probably wrong
+        rrp->tried = (ptraddr_t*)&rrp->data;
         rrp->data = 0;
 
     } else {
@@ -522,7 +524,7 @@ static ngx_http_upstream_rr_peer_t *
 ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
 {
     time_t                        now;
-    uintptr_t                     m;
+    ptraddr_t                     m;
     ngx_int_t                     total;
     ngx_uint_t                    i, n, p;
     ngx_http_upstream_rr_peer_t  *peer, *best;
@@ -541,7 +543,7 @@ ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
          peer = peer->next, i++)
     {
         n = i / (8 * sizeof(uintptr_t));
-        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));
+        m = (ptraddr_t) 1 << i % (8 * sizeof(uintptr_t));
 
         if (rrp->tried[n] & m) {
             continue;
@@ -582,7 +584,7 @@ ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
     rrp->current = best;
 
     n = p / (8 * sizeof(uintptr_t));
-    m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+    m = (ptraddr_t) 1 << p % (8 * sizeof(uintptr_t));
 
     rrp->tried[n] |= m;
 
diff --git src/http/ngx_http_upstream_round_robin.h src/http/ngx_http_upstream_round_robin.h
index 922ceaa0..05be35e1 100644
--- src/http/ngx_http_upstream_round_robin.h
+++ src/http/ngx_http_upstream_round_robin.h
@@ -129,7 +129,7 @@ typedef struct {
     ngx_uint_t                      config;
     ngx_http_upstream_rr_peers_t   *peers;
     ngx_http_upstream_rr_peer_t    *current;
-    uintptr_t                      *tried;
+    ptraddr_t                      *tried;
     uintptr_t                       data;
 } ngx_http_upstream_rr_peer_data_t;
 
diff --git src/os/unix/ngx_alloc.c src/os/unix/ngx_alloc.c
index 5c2f7870..c5848e57 100644
--- src/os/unix/ngx_alloc.c
+++ src/os/unix/ngx_alloc.c
@@ -69,6 +69,9 @@ ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)
 }
 
 #elif (NGX_HAVE_MEMALIGN)
+#ifdef __CHERI_PURE_CAPABILITY__
+#error should be using posix_memalign
+#endif
 
 void *
 ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)
diff --git src/os/unix/ngx_alloc.h src/os/unix/ngx_alloc.h
index 655db257..e38599e0 100644
--- src/os/unix/ngx_alloc.h
+++ src/os/unix/ngx_alloc.h
@@ -13,8 +13,8 @@
 #include <ngx_core.h>
 
 
-void *ngx_alloc(size_t size, ngx_log_t *log);
-void *ngx_calloc(size_t size, ngx_log_t *log);
+void *ngx_alloc(size_t size, ngx_log_t *log) __attribute__((alloc_size(1)));
+void *ngx_calloc(size_t size, ngx_log_t *log) __attribute__((alloc_size(1)));
 
 #define ngx_free          free
 
@@ -28,7 +28,7 @@ void *ngx_calloc(size_t size, ngx_log_t *log);
 
 #if (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)
 
-void *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log);
+void *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log) __attribute__((alloc_size(2)));
 
 #else
 
