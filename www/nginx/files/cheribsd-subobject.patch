diff --git src/core/ngx_core.h src/core/ngx_core.h
index 7ecdca0cb..2b7537125 100644
--- src/core/ngx_core.h
+++ src/core/ngx_core.h
@@ -8,7 +8,7 @@
 #ifndef _NGX_CORE_H_INCLUDED_
 #define _NGX_CORE_H_INCLUDED_
 
-
+#include <sys/cdefs.h>
 #include <ngx_config.h>
 
 
@@ -42,6 +42,29 @@ typedef void (*ngx_connection_handler_pt)(ngx_connection_t *c);
 #define  NGX_DECLINED   -5
 #define  NGX_ABORT      -6
 
+#ifdef WITH_SUBOBJECT_AGGRESSIVE
+#ifndef WITH_SUBOBJECT_SAFE
+#define WITH_SUBOBJECT_SAFE
+#endif
+#endif
+
+#ifdef WITH_SUBOBJECT_SAFE
+#define _ngx_safe_no_subobject_bounds __no_subobject_bounds
+#define _ngx_safe_container_bounds __subobject_use_container_bounds
+#else
+#define _ngx_safe_no_subobject_bounds
+#define _ngx_safe_container_bounds
+#endif /* WITH_SUBOBJECT_SAFE */
+
+#ifdef WITH_SUBOBJECT_AGGRESSIVE
+#define _ngx_aggressive_no_subobject_bounds __no_subobject_bounds
+#define _ngx_aggressive_unbounded_addressof __unbounded_addressof
+#define _ngx_aggressive_bounded_addressof __bounded_addressof
+#else
+#define _ngx_aggressive_no_subobject_bounds
+#define _ngx_aggressive_unbounded_addressof(x) (&x)
+#define _ngx_aggressive_bounded_addressof(x, sz) (&x)
+#endif /* WITH_SUBOBJECT_AGGRESSIVE */
 
 #include <ngx_errno.h>
 #include <ngx_atomic.h>
diff --git src/core/ngx_hash.c src/core/ngx_hash.c
index 4ba10df41..ce27c4d9d 100644
--- src/core/ngx_hash.c
+++ src/core/ngx_hash.c
@@ -79,7 +79,8 @@ ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
     ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, "key:\"%ui\"", key);
 #endif
 
-    value = ngx_hash_find(&hwc->hash, key, &name[n], len - n);
+    value = ngx_hash_find(&hwc->hash, key,
+        _ngx_aggressive_unbounded_addressof(name[n]), len - n);
 
 #if 0
     ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, "value:\"%p\"", value);
@@ -189,7 +190,8 @@ ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
 
             hwc = (ngx_hash_wildcard_t *) cheri_clear_low_ptr_bits((uintptr_t)value, 3);
 
-            value = ngx_hash_find_wc_tail(hwc, &name[i], len - i);
+            value = ngx_hash_find_wc_tail(hwc,
+                _ngx_aggressive_bounded_addressof(name[i], len - i), len - i);
 
             if (value) {
                 return value;
@@ -855,7 +857,10 @@ wildcard:
 
     /* wildcard hash */
 
-    k = ngx_hash_strlow(&key->data[skip], &key->data[skip], last - skip);
+    k = ngx_hash_strlow(
+        _ngx_aggressive_bounded_addressof(key->data[skip], last - skip),
+        _ngx_aggressive_bounded_addressof(key->data[skip], last - skip),
+        last - skip);
 
     k %= ha->hsize;
 
diff --git src/core/ngx_inet.c src/core/ngx_inet.c
index 4228504ad..7e7e3b664 100644
--- src/core/ngx_inet.c
+++ src/core/ngx_inet.c
@@ -224,10 +224,11 @@ ngx_sock_ntop(struct sockaddr *sa, socklen_t socklen, u_char *text, size_t len,
             text[n++] = '[';
         }
 
-        n = ngx_inet6_ntop(sin6->sin6_addr.s6_addr, &text[n], len);
+        n = ngx_inet6_ntop(sin6->sin6_addr.s6_addr,
+            _ngx_aggressive_unbounded_addressof(text[n]), len);
 
         if (port) {
-            n = ngx_sprintf(&text[1 + n], "]:%d",
+            n = ngx_sprintf(_ngx_aggressive_unbounded_addressof(text[1 + n]), "]:%d",
                             ntohs(sin6->sin6_port)) - text;
         }
 
diff --git src/core/ngx_queue.h src/core/ngx_queue.h
index 038bf1211..6a01e7b61 100644
--- src/core/ngx_queue.h
+++ src/core/ngx_queue.h
@@ -4,7 +4,6 @@
  * Copyright (C) Nginx, Inc.
  */
 
-
 #include <ngx_config.h>
 #include <ngx_core.h>
 
@@ -18,7 +17,7 @@ typedef struct ngx_queue_s  ngx_queue_t;
 struct ngx_queue_s {
     ngx_queue_t  *prev;
     ngx_queue_t  *next;
-};
+} _ngx_safe_container_bounds;
 
 
 #define ngx_queue_init(q)                                                     \
diff --git src/core/ngx_rbtree.h src/core/ngx_rbtree.h
index e8c358213..70bc613e1 100644
--- src/core/ngx_rbtree.h
+++ src/core/ngx_rbtree.h
@@ -26,7 +26,7 @@ struct ngx_rbtree_node_s {
     ngx_rbtree_node_t     *parent;
     u_char                 color;
     u_char                 data;
-};
+} _ngx_safe_container_bounds;
 
 
 typedef struct ngx_rbtree_s  ngx_rbtree_t;
diff --git src/core/ngx_resolver.c src/core/ngx_resolver.c
index c76c17852..ecc9bb97c 100644
--- src/core/ngx_resolver.c
+++ src/core/ngx_resolver.c
@@ -1855,7 +1855,7 @@ found:
         goto short_response;
     }
 
-    qs = (ngx_resolver_qs_t *) &buf[i];
+    qs = (ngx_resolver_qs_t *) _ngx_aggressive_bounded_addressof(buf[i], sizeof(*qs));
 
     qtype = (qs->type_hi << 8) + qs->type_lo;
     qclass = (qs->class_hi << 8) + qs->class_lo;
@@ -2189,7 +2189,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,
             goto short_response;
         }
 
-        an = (ngx_resolver_an_t *) &buf[i];
+        an = (ngx_resolver_an_t *) _ngx_aggressive_bounded_addressof(buf[i], sizeof(*an));
 
         type = (an->type_hi << 8) + an->type_lo;
         class = (an->class_hi << 8) + an->class_lo;
@@ -2257,7 +2257,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,
 
         case NGX_RESOLVE_CNAME:
 
-            cname = &buf[i];
+            cname = _ngx_aggressive_unbounded_addressof(buf[i]);
 
             break;
 
@@ -2347,7 +2347,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,
                 i += 1 + buf[i];
             }
 
-            an = (ngx_resolver_an_t *) &buf[i];
+            an = (ngx_resolver_an_t *) _ngx_aggressive_bounded_addressof(buf[i], sizeof(*an));
 
             type = (an->type_hi << 8) + an->type_lo;
             len = (an->len_hi << 8) + an->len_lo;
@@ -2374,7 +2374,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,
 #if (NGX_HAVE_INET6)
             else if (type == NGX_RESOLVE_AAAA) {
 
-                ngx_memcpy(addr6[j].s6_addr, &buf[i], 16);
+                ngx_memcpy(addr6[j].s6_addr, _ngx_aggressive_bounded_addressof(buf[i], 16), 16);
 
                 if (++j == naddrs) {
 
@@ -2761,7 +2761,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,
                 goto short_response;
             }
 
-            if (ngx_resolver_copy(r, NULL, buf, &buf[i + 6], buf + n)
+            if (ngx_resolver_copy(r, NULL, buf, _ngx_aggressive_unbounded_addressof(buf[i + 6]), buf + n)
                 != NGX_OK)
             {
                 goto failed;
@@ -2773,7 +2773,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,
 
         case NGX_RESOLVE_CNAME:
 
-            cname = &buf[i];
+            cname = _ngx_aggressive_unbounded_addressof(buf[i]);
 
             break;
 
@@ -2842,7 +2842,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,
 
                 srvs[j].port = (buf[i + 4] << 8) + buf[i + 5];
 
-                if (ngx_resolver_copy(r, &srvs[j].name, buf, &buf[i + 6],
+                if (ngx_resolver_copy(r, &srvs[j].name, buf, _ngx_aggressive_unbounded_addressof(buf[i + 6]),
                                       buf + n)
                     != NGX_OK)
                 {
@@ -4008,11 +4008,11 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,
             }
 
             n = ((n & 0x3f) << 8) + *p;
-            p = &buf[n];
+            p = _ngx_aggressive_unbounded_addressof(buf[n]);
 
         } else {
             len += 1 + n;
-            p = &p[n];
+            p = _ngx_aggressive_unbounded_addressof(p[n]);
         }
 
         if (p >= last) {
@@ -4057,7 +4057,7 @@ done:
 
         if (n & 0xc0) {
             n = ((n & 0x3f) << 8) + *src;
-            src = &buf[n];
+            src = _ngx_aggressive_unbounded_addressof(buf[n]);
 
         } else {
             ngx_strlow(dst, src, n);
diff --git src/core/ngx_slab.c src/core/ngx_slab.c
index 5836a67b0..8a45b64f5 100644
--- src/core/ngx_slab.c
+++ src/core/ngx_slab.c
@@ -4,6 +4,7 @@
  * Copyright (C) Nginx, Inc.
  */
 
+#include <cheri/cheric.h>
 #include <ngx_config.h>
 #include <ngx_core.h>
 
@@ -40,8 +41,11 @@
 
 #endif
 
-
-#define ngx_slab_slots(pool)                                                  \
+/*
+ * XXX-AM: It would be nice to make this exactly representable.
+ * We should probably cache a capability to the slots in the pool?
+ */
+#define ngx_slab_slots(pool)                                        \
     (ngx_slab_page_t *) ((u_char *) (pool) + sizeof(ngx_slab_pool_t))
 
 #define ngx_slab_page_type(page)   cheri_get_low_ptr_bits((page)->prev, NGX_SLAB_PAGE_MASK)
@@ -124,7 +128,12 @@ ngx_slab_init(ngx_slab_pool_t *pool)
 
     p += n * sizeof(ngx_slab_page_t);
 
+#if __has_feature(capabilities)
+    pool->stats = (ngx_slab_stat_t *) cheri_setbounds(
+        p, n * sizeof(ngx_slab_stat_t));
+#else
     pool->stats = (ngx_slab_stat_t *) p;
+#endif
     ngx_memzero(pool->stats, n * sizeof(ngx_slab_stat_t));
 
     p += n * sizeof(ngx_slab_stat_t);
@@ -133,7 +142,11 @@ ngx_slab_init(ngx_slab_pool_t *pool)
 
     pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));
 
+#if __has_feature(capabilities)
+    pool->pages = (ngx_slab_page_t *) cheri_setbounds(p, pages * sizeof(ngx_slab_page_t));
+#else
     pool->pages = (ngx_slab_page_t *) p;
+#endif
     ngx_memzero(pool->pages, pages * sizeof(ngx_slab_page_t));
 
     page = pool->pages;
@@ -684,15 +697,17 @@ ngx_slab_alloc_pages(ngx_slab_pool_t *pool, ngx_uint_t pages)
         if (page->slab >= pages) {
 
             if (page->slab > pages) {
-                page[page->slab - 1].prev = (uintptr_t) &page[pages];
+                page[page->slab - 1].prev =
+                    (uintptr_t) _ngx_aggressive_unbounded_addressof(page[pages]);
 
                 page[pages].slab = page->slab - pages;
                 page[pages].next = page->next;
                 page[pages].prev = page->prev;
 
                 p = (ngx_slab_page_t *) page->prev;
-                p->next = &page[pages];
-                page->next->prev = (uintptr_t) &page[pages];
+                p->next = _ngx_aggressive_unbounded_addressof(page[pages]);
+                page->next->prev =
+                    (uintptr_t) _ngx_aggressive_unbounded_addressof(page[pages]);
 
             } else {
                 p = (ngx_slab_page_t *) page->prev;
@@ -741,7 +756,8 @@ ngx_slab_free_pages(ngx_slab_pool_t *pool, ngx_slab_page_t *page,
     page->slab = pages--;
 
     if (pages) {
-        ngx_memzero(&page[1], pages * sizeof(ngx_slab_page_t));
+        ngx_memzero(_ngx_aggressive_unbounded_addressof(page[1]),
+                    pages * sizeof(ngx_slab_page_t));
     }
 
     if (page->next) {
diff --git src/core/ngx_slab.h src/core/ngx_slab.h
index 1886c126b..962ab4c06 100644
--- src/core/ngx_slab.h
+++ src/core/ngx_slab.h
@@ -8,7 +8,6 @@
 #ifndef _NGX_SLAB_H_INCLUDED_
 #define _NGX_SLAB_H_INCLUDED_
 
-
 #include <ngx_config.h>
 #include <ngx_core.h>
 
diff --git src/http/modules/ngx_http_log_module.c src/http/modules/ngx_http_log_module.c
index 82717775e..d3858b0bd 100644
--- src/http/modules/ngx_http_log_module.c
+++ src/http/modules/ngx_http_log_module.c
@@ -1621,7 +1621,7 @@ ngx_http_log_compile_format(ngx_conf_t *cf, ngx_array_t *flushes,
                 return NGX_CONF_ERROR;
             }
 
-            data = &value[s].data[i];
+            data = _ngx_aggressive_unbounded_addressof(value[s].data[i]);
 
             if (value[s].data[i] == '$') {
 
@@ -1636,11 +1636,11 @@ ngx_http_log_compile_format(ngx_conf_t *cf, ngx_array_t *flushes,
                         goto invalid;
                     }
 
-                    var.data = &value[s].data[i];
+                    var.data = _ngx_aggressive_unbounded_addressof(value[s].data[i]);
 
                 } else {
                     bracket = 0;
-                    var.data = &value[s].data[i];
+                    var.data = _ngx_aggressive_unbounded_addressof(value[s].data[i]);
                 }
 
                 for (var.len = 0; i < value[s].len; i++, var.len++) {
diff --git src/http/ngx_http_core_module.c src/http/ngx_http_core_module.c
index 3a12045e5..ea4ed5b28 100644
--- src/http/ngx_http_core_module.c
+++ src/http/ngx_http_core_module.c
@@ -872,7 +872,8 @@ ngx_http_core_run_phases(ngx_http_request_t *r)
 
     while (ph[r->phase_handler].checker) {
 
-        rc = ph[r->phase_handler].checker(r, &ph[r->phase_handler]);
+        rc = ph[r->phase_handler].checker(r,
+            _ngx_aggressive_unbounded_addressof(ph[r->phase_handler]));
 
         if (rc == NGX_OK) {
             return;
@@ -1658,7 +1659,8 @@ ngx_http_set_exten(ngx_http_request_t *r)
         if (r->uri.data[i] == '.' && r->uri.data[i - 1] != '/') {
 
             r->exten.len = r->uri.len - i - 1;
-            r->exten.data = &r->uri.data[i + 1];
+            r->exten.data = _ngx_aggressive_bounded_addressof(
+                r->uri.data[i + 1], r->exten.len);
 
             return;
 
@@ -4792,7 +4794,9 @@ ngx_http_core_error_page(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
         }
 
         if (value[i].len > 1) {
-            overwrite = ngx_atoi(&value[i].data[1], value[i].len - 1);
+            overwrite = ngx_atoi(
+                _ngx_aggressive_bounded_addressof(value[i].data[1], value[i].len - 1),
+                value[i].len - 1);
 
             if (overwrite == NGX_ERROR) {
                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
@@ -5026,7 +5030,10 @@ ngx_http_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 
     value = cf->args->elts;
 
-    clcf->resolver = ngx_resolver_create(cf, &value[1], cf->args->nelts - 1);
+    clcf->resolver = ngx_resolver_create(cf,
+        _ngx_aggressive_bounded_addressof(value[1],
+            sizeof(*value) * (cf->args->nelts - 1)),
+        cf->args->nelts - 1);
     if (clcf->resolver == NULL) {
         return NGX_CONF_ERROR;
     }
diff --git src/http/ngx_http_request.h src/http/ngx_http_request.h
index 8c9eed249..ea8a4ae28 100644
--- src/http/ngx_http_request.h
+++ src/http/ngx_http_request.h
@@ -373,6 +373,9 @@ struct ngx_http_posted_request_s {
 typedef ngx_int_t (*ngx_http_handler_pt)(ngx_http_request_t *r);
 typedef void (*ngx_http_event_handler_pt)(ngx_http_request_t *r);
 
+typedef struct {
+    ngx_http_posted_request_t         terminal_posted_request;
+} ngx_http_ephemeral_t;
 
 struct ngx_http_request_s {
     uint32_t                          signature;         /* "HTTP" */
@@ -581,8 +584,30 @@ struct ngx_http_request_s {
     /*
      * a memory that can be reused after parsing a request line
      * via ngx_http_ephemeral_t
+     *
+     * XXX-AM: This seems to be implicitly an union of the following fields.
+     * Sub-object bounds require us to be explicit.
      */
-
+#ifdef WITH_SUBOBJECT_SAFE
+    union {
+        struct {
+            u_char                   *uri_start;
+            u_char                   *uri_end;
+            u_char                   *uri_ext;
+            u_char                   *args_start;
+            u_char                   *request_start;
+            u_char                   *request_end;
+            u_char                   *method_end;
+            u_char                   *schema_start;
+            u_char                   *schema_end;
+            u_char                   *host_start;
+            u_char                   *host_end;
+            u_char                   *port_start;
+            u_char                   *port_end;
+        };
+        ngx_http_ephemeral_t _ephemeral;
+    };
+#else
     u_char                           *uri_start;
     u_char                           *uri_end;
     u_char                           *uri_ext;
@@ -596,18 +621,18 @@ struct ngx_http_request_s {
     u_char                           *host_end;
     u_char                           *port_start;
     u_char                           *port_end;
+#endif
 
     unsigned                          http_minor:16;
     unsigned                          http_major:16;
 };
 
 
-typedef struct {
-    ngx_http_posted_request_t         terminal_posted_request;
-} ngx_http_ephemeral_t;
-
-
+#ifdef WITH_SUBOBJECT_SAFE
+#define ngx_http_ephemeral(r)  (void *) (&r->_ephemeral)
+#else
 #define ngx_http_ephemeral(r)  (void *) (&r->uri_start)
+#endif
 
 
 extern ngx_http_header_t       ngx_http_headers_in[];
diff --git src/http/ngx_http_script.c src/http/ngx_http_script.c
index 9c10408c0..4d534113a 100644
--- src/http/ngx_http_script.c
+++ src/http/ngx_http_script.c
@@ -511,11 +511,11 @@ ngx_http_script_compile(ngx_http_script_compile_t *sc)
                     goto invalid_variable;
                 }
 
-                name.data = &sc->source->data[i];
+                name.data = _ngx_aggressive_unbounded_addressof(sc->source->data[i]);
 
             } else {
                 bracket = 0;
-                name.data = &sc->source->data[i];
+                name.data = _ngx_aggressive_unbounded_addressof(sc->source->data[i]);
             }
 
             for ( /* void */ ; i < sc->source->len; i++, name.len++) {
@@ -571,7 +571,7 @@ ngx_http_script_compile(ngx_http_script_compile_t *sc)
             continue;
         }
 
-        name.data = &sc->source->data[i];
+        name.data = _ngx_aggressive_unbounded_addressof(sc->source->data[i]);
 
         while (i < sc->source->len) {
 
@@ -1400,7 +1400,8 @@ ngx_http_script_copy_capture_code(ngx_http_script_engine_t *e)
                                                cap[n + 1] - cap[n],
                                                NGX_ESCAPE_ARGS);
         } else {
-            e->pos = ngx_copy(pos, &p[cap[n]], cap[n + 1] - cap[n]);
+            e->pos = ngx_copy(pos, _ngx_aggressive_unbounded_addressof(p[cap[n]]),
+                              cap[n + 1] - cap[n]);
         }
     }
 
diff --git src/http/ngx_http_variables.c src/http/ngx_http_variables.c
index 16ffda3fe..a07a31edf 100644
--- src/http/ngx_http_variables.c
+++ src/http/ngx_http_variables.c
@@ -2587,7 +2587,7 @@ ngx_http_regex_compile(ngx_conf_t *cf, ngx_regex_compile_t *rc)
     for (i = 0; i < n; i++) {
         rv[i].capture = 2 * ((p[0] << 8) + p[1]);
 
-        name.data = &p[2];
+        name.data = _ngx_aggressive_unbounded_addressof(p[2]);
         name.len = ngx_strlen(name.data);
 
         v = ngx_http_add_variable(cf, &name, NGX_HTTP_VAR_CHANGEABLE);
@@ -2658,7 +2658,7 @@ ngx_http_regex_exec(ngx_http_request_t *r, ngx_http_regex_t *re, ngx_str_t *s)
         vv->valid = 1;
         vv->no_cacheable = 0;
         vv->not_found = 0;
-        vv->data = &s->data[r->captures[n]];
+        vv->data = _ngx_aggressive_unbounded_addressof(s->data[r->captures[n]]);
 
 #if (NGX_DEBUG)
         {
