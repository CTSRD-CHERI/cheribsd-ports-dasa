diff --git README-morello.md README-morello.md
new file mode 100644
index 000000000..4ea5f5d4f
--- /dev/null
+++ README-morello.md
@@ -0,0 +1,176 @@
+# Background
+
+This software is an experimental Morello port of nginx v1.22.0.
+
+## Build instructions
+
+nginx is build with GNU make (gmake), first install this build dependency
+as follows:
+
+`$ sudo pkg64 install gmake`
+
+Once installed nginx can be built as follows
+(see `auto/configure --help` for a complete list of options):
+ 
+```
+$ auto/configure
+	--with-cc-opt='-Wno-cheri-provenance'
+	--without-http_geo_module
+	--with-http_ssl_module
+	--with-pcre
+	--with-compat
+$ gmake
+$ sudo gmake install
+```
+
+## Run instructions
+
+Once installed nginx can be started by specifying a configuration file as:
+ 
+`sudo /usr/local/sbin/nginx -c <conf>`
+
+To stop the server:
+
+`sudo /usr/local/nginx/sbin/nginx -s stop`
+
+Further details ons starting and stopping nginx and writting a configuration
+file can be found,
+[Starting, Stopping, and Restarting NGINX](https://www.nginx.com/resources/wiki/start/topics/tutorials/commandline/) and
+[Creating NGINX Plus and NGINX Configuration Files](https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/).
+
+## Library compartmentalization
+
+When using Library compartmentalisation nginx must be build with the 
+following flags: `-Xclang -morello-bounded-memargs=caller-only`.
+
+Following the instructions given by in `man c18n` the runtime linker can either
+be changed to support library compartmentalisation when running configure:
+
+`$ auto/configure --with-ld-opt="-Wl,--dynamic-linker=/libexec/ld-elf-c18n.so.1"` 
+
+or can be changed after the nginx binary has been created using patchelf:
+
+```
+$ sudo patchelf --set-interpreter /libexec/ld-elf-c18n.so.1  /usr/local/sbin/nginx
+```
+
+The change of runtime linker can be verified with either readelf or patchelf
+as below:
+
+```
+$ readelf -l /usr/local/nginx/sbin/nginx
+
+Elf file type is DYN (Shared object file)
+Entry point 0x6ae01
+There are 11 program headers, starting at offset 64
+
+Program Headers:
+  Type           Offset             VirtAddr           PhysAddr
+                 FileSiz            MemSiz              Flg    Align
+  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
+                 0x0000000000000268 0x0000000000000268  R      0x8
+  INTERP         0x0000000000000400 0x0000000000000400 0x0000000000000400
+                 0x0000000000000015 0x0000000000000015  R      0x1
+      [Requesting program interpreter: /libexec/ld-elf.so.1]
+...
+
+$ patchelf --print-interpreter /usr/local/sbin/nginx
+/libexec/ld-elf-c18n.so.1
+```
+
+To start nginx the modifed runtime linker must be able to locate the following
+library: `libpcre.so.1`. This can be achieved by specifying the environmental
+variable `LD_C18N_LIBRARY_PATH` as follows:
+
+`$ sudo LD_C18N_LIBRARY_PATH=/usr/local/lib /usr/local/nginx/sbin/nginx -c ...`
+
+nginx should then start running with shared libraries within seperate
+compartmentments (manged and enforced by the updated runtime linker).
+
+## Testing
+
+### Unit testing
+
+Unit testing has been performed using a corpus of Perl scripts
+[nginx-tests](http://hg.nginx.org/nginx-tests). The core HTTP function can be
+tested as (this require installation of Perl to provide the `prove` command
+line utility):
+
+```
+TEST_NGINX_BINARY=/usr/local/nginx/sbin/nginx prove http*
+http_absolute_redirect.t .... ok
+http_disable_symlinks.t ..... skipped: no disable_symlinks
+http_error_page.t ........... ok
+http_expect_100_continue.t .. ok
+http_header_buffers.t ....... ok
+http_headers_multi.t ........ ok
+http_host.t ................. ok
+http_include.t .............. ok
+http_keepalive.t ............ ok
+http_keepalive_shutdown.t ... ok
+http_listen.t ............... ok
+http_listen_wildcard.t ...... skipped: listen on wildcard address
+http_location.t ............. ok
+http_location_auto.t ........ ok
+http_location_win32.t ....... skipped: not win32
+http_method.t ............... ok
+http_resolver.t ............. ok
+http_resolver_aaaa.t ........ ok
+http_resolver_cleanup.t ..... ok
+http_resolver_cname.t ....... ok
+http_resolver_ipv4.t ........ skipped: no resolver ipv4
+http_server_name.t .......... ok
+http_try_files.t ............ ok
+http_uri.t .................. ok
+http_variables.t ............ ok
+All tests successful.
+Files=25, Tests=402, 67 wallclock secs ( 0.20 usr  0.05 sys +  4.80 cusr  1.07 csys =  6.11 CPU)
+Result: PASS
+```
+
+NOTE: That the `http_header_buffers.t` script requires increasing the
+connection pool size to 224.
+
+To run the unit tests with the runtime linker for library compartmentalisation
+include the `LD_C18N_LIBRARY_PATH` environmental variable:
+
+`LD_C18N_LIBRARY_PATH=/usr/local/lib TEST_NGINX_BINARY=/usr/local/nginx/sbin/nginx prove http*`
+
+### Performance testing
+
+Performance testing is performed using the `wrk` benchmark, as described
+in [Testing the Performance of NGINX and NGINX Plus Web Servers](https://www.nginx.com/blog/testing-the-performance-of-nginx-and-nginx-plus-web-servers/).
+
+`./wrk -t 1 -c 50 -d 15s --latency https://192.168.2.2/1kb.bin`
+
+## Notes and Limitations
+
+As which many configure scripts, `-Werror` is enabled. This results in many
+ambiguous provenance warnings which (in theses cases) bening being promoted
+to errors. As in this case the warnings are benign instead of making
+disruptive and disruptive changes to the code the configure should be
+passed the `--with-cc-opt='-Wno-cheri-provenenace` flags.
+
+The `http_geo_module` performs a cast of a pointer difference to a pointer.
+This results in a capability misuse as the resulting pointer can't be
+dereferenced. 
+
+Adaptations to nginx to the memory-safe CheriABI have been driven by:
+compiler warnings and errors, and dynamic testing. Where the compiler
+emits a warning or error we are able to rigorously review this and
+correct. However, some issues only manifest dynamically (at runtime),
+such as invalidation of capabilities by pointer arithmetic,
+non-blessed memory copies, or insufficient pointer alignment.
+Enhancements such as CHERI UBsan have modestly improved the ability to
+identify problems previously only found during dynamic testing. However,
+ we are still greatly reliant on dynamic testing. This testing is
+constrained by both the completeness of the test suites (which in some
+cases provide poor coverage) and the time available within the project
+to perform testing. Whilst it is know that errors remain outside the
+core http module we are not able to estimate what problems might
+remain beyond those resolved in the scope of the project.
+
+## Acknowledgement
+
+This work has been undertaken within DSTL contract
+ACC6036483: CHERI-based compartmentalisation for web services on Morello.
diff --git auto/types/sizeof auto/types/sizeof
index 480d8cfa4..5ee689520 100644
--- auto/types/sizeof
+++ auto/types/sizeof
@@ -56,6 +56,11 @@ case $ngx_size in
         ngx_max_len='(sizeof("-9223372036854775808") - 1)'
     ;;
 
+    16)
+        ngx_max_value=9223372036854775807LL
+        ngx_max_len='(sizeof("-9223372036854775808") - 1)'
+    ;;
+
     *)
         echo
         echo "$0: error: can not detect $ngx_type size"
diff --git conf/nginx.conf conf/nginx.conf
index 29bc085f2..0c8678521 100644
--- conf/nginx.conf
+++ conf/nginx.conf
@@ -32,6 +32,9 @@ http {
 
     #gzip  on;
 
+    types_hash_bucket_size 128;
+    variables_hash_bucket_size 128;
+
     server {
         listen       80;
         server_name  localhost;
diff --git src/core/ngx_array.c src/core/ngx_array.c
index 4ea226f06..dae4b8696 100644
--- src/core/ngx_array.c
+++ src/core/ngx_array.c
@@ -59,6 +59,18 @@ ngx_array_push(ngx_array_t *a)
 
         p = a->pool;
 
+#if defined(__CHERI_PURE_CAPABILITY__)
+	/* allocate a new array */
+
+	new = ngx_palloc(p, 2 * size);
+	if (new == NULL) {
+	return NULL;
+	}
+
+	ngx_memcpy(new, a->elts, size);
+	a->elts = new;
+	a->nalloc *= 2;
+#else
         if ((u_char *) a->elts + size == p->d.last
             && p->d.last + a->size <= p->d.end)
         {
@@ -82,6 +94,7 @@ ngx_array_push(ngx_array_t *a)
             a->elts = new;
             a->nalloc *= 2;
         }
+#endif
     }
 
     elt = (u_char *) a->elts + a->size * a->nelts;
diff --git src/core/ngx_config.h src/core/ngx_config.h
index 1861be601..dab593c20 100644
--- src/core/ngx_config.h
+++ src/core/ngx_config.h
@@ -43,6 +43,10 @@
 
 #endif
 
+#ifndef __has_builtin
+#define __has_builtin(x) 0
+#endif
+
 
 #ifndef NGX_HAVE_SO_SNDLOWAT
 #define NGX_HAVE_SO_SNDLOWAT     1
@@ -79,6 +83,12 @@ typedef intptr_t        ngx_int_t;
 typedef uintptr_t       ngx_uint_t;
 typedef intptr_t        ngx_flag_t;
 
+#ifdef _PTRADDR_T_DECLARED
+typedef ptraddr_t	ngx_ptraddr_t;
+#else
+typedef uintptr_t	ngx_ptraddr_t;
+#endif
+
 
 #define NGX_INT32_LEN   (sizeof("-2147483648") - 1)
 #define NGX_INT64_LEN   (sizeof("-9223372036854775808") - 1)
@@ -97,9 +107,14 @@ typedef intptr_t        ngx_flag_t;
 #define NGX_ALIGNMENT   sizeof(unsigned long)    /* platform word */
 #endif
 
+#if __has_builtin(__builtin_align_up)
+#define ngx_align(d, a)     __builtin_align_up(d, a)
+#define ngx_align_ptr(p, a) __builtin_align_up(p, a)
+#else
 #define ngx_align(d, a)     (((d) + (a - 1)) & ~(a - 1))
 #define ngx_align_ptr(p, a)                                                   \
     (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) & ~((uintptr_t) a - 1))
+#endif
 
 
 #define ngx_abort       abort
@@ -141,5 +156,12 @@ typedef intptr_t        ngx_flag_t;
 
 #endif
 
+/* XXXAR: For the low pointer bits macros */
+#if __has_include(<cheri/cheric.h>)
+#include <cheri/cheric.h>
+#else
+#include <cheri.h>
+#endif
+
 
 #endif /* _NGX_CONFIG_H_INCLUDED_ */
diff --git src/core/ngx_crc32.c src/core/ngx_crc32.c
index a5b4017b8..ff66ffdf9 100644
--- src/core/ngx_crc32.c
+++ src/core/ngx_crc32.c
@@ -107,9 +107,7 @@ ngx_crc32_table_init(void)
 {
     void  *p;
 
-    if (((uintptr_t) ngx_crc32_table_short
-          & ~((uintptr_t) ngx_cacheline_size - 1))
-        == (uintptr_t) ngx_crc32_table_short)
+    if (__builtin_is_aligned(ngx_crc32_table_short, ngx_cacheline_size))
     {
         return NGX_OK;
     }
diff --git src/core/ngx_hash.c src/core/ngx_hash.c
index 8215c2717..4ba10df41 100644
--- src/core/ngx_hash.c
+++ src/core/ngx_hash.c
@@ -97,23 +97,21 @@ ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
          *     11 - value is pointer to wildcard hash allowing
          *          "*.example.com" only.
          */
-
-        if ((uintptr_t) value & 2) {
+        if (cheri_get_low_ptr_bits((uintptr_t) value, 2)) {
 
             if (n == 0) {
 
                 /* "example.com" */
 
-                if ((uintptr_t) value & 1) {
+                if (cheri_get_low_ptr_bits((uintptr_t) value, 1)) {
                     return NULL;
                 }
 
-                hwc = (ngx_hash_wildcard_t *)
-                                          ((uintptr_t) value & (uintptr_t) ~3);
+                hwc = (ngx_hash_wildcard_t *)cheri_clear_low_ptr_bits((uintptr_t)value, 3);
                 return hwc->value;
             }
 
-            hwc = (ngx_hash_wildcard_t *) ((uintptr_t) value & (uintptr_t) ~3);
+            hwc = (ngx_hash_wildcard_t *) cheri_clear_low_ptr_bits((uintptr_t)value, 3);
 
             value = ngx_hash_find_wc_head(hwc, name, n - 1);
 
@@ -124,7 +122,7 @@ ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
             return hwc->value;
         }
 
-        if ((uintptr_t) value & 1) {
+        if (cheri_get_low_ptr_bits((uintptr_t) value, 1)) {
 
             if (n == 0) {
 
@@ -133,7 +131,7 @@ ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
                 return NULL;
             }
 
-            return (void *) ((uintptr_t) value & (uintptr_t) ~3);
+            return (void *) cheri_clear_low_ptr_bits((uintptr_t)value, 3);
         }
 
         return value;
@@ -185,11 +183,11 @@ ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
          *     11 - value is pointer to wildcard hash allowing "example.*".
          */
 
-        if ((uintptr_t) value & 2) {
+        if (cheri_get_low_ptr_bits((uintptr_t) value, 2)) {
 
             i++;
 
-            hwc = (ngx_hash_wildcard_t *) ((uintptr_t) value & (uintptr_t) ~3);
+            hwc = (ngx_hash_wildcard_t *) cheri_clear_low_ptr_bits((uintptr_t)value, 3);
 
             value = ngx_hash_find_wc_tail(hwc, &name[i], len - i);
 
diff --git src/core/ngx_palloc.c src/core/ngx_palloc.c
index d3044ac9c..4b9578f3b 100644
--- src/core/ngx_palloc.c
+++ src/core/ngx_palloc.c
@@ -20,6 +20,12 @@ ngx_create_pool(size_t size, ngx_log_t *log)
 {
     ngx_pool_t  *p;
 
+    if (size < sizeof(ngx_pool_t))
+        size = sizeof(ngx_pool_t);
+#ifdef __CHERI_PURE_CAPABILITY__
+    size = __builtin_cheri_round_representable_length(size);
+#endif
+
     p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);
     if (p == NULL) {
         return NULL;
@@ -160,9 +166,15 @@ ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)
             m = ngx_align_ptr(m, NGX_ALIGNMENT);
         }
 
-        if ((size_t) (p->d.end - m) >= size) {
+        // Alignment can overflow buffer, need to use a signed type
+        if ((ssize_t) (p->d.end - m) >= (ssize_t) size) {
             p->d.last = m + size;
 
+#ifdef __CHERI_PURE_CAPABILITY__
+            // This is safe so long as NGX_MAX_ALLOC_FROM_POOL is
+            // representable.  By default it's 4095 so safe.
+            m = cheri_setboundsexact(m, size);
+#endif
             return m;
         }
 
@@ -206,6 +218,9 @@ ngx_palloc_block(ngx_pool_t *pool, size_t size)
 
     p->d.next = new;
 
+#ifdef __CHERI_PURE_CAPABILITY__
+    m = cheri_setboundsexact(m, size);
+#endif
     return m;
 }
 
diff --git src/core/ngx_palloc.h src/core/ngx_palloc.h
index 376e01283..e9403076b 100644
--- src/core/ngx_palloc.h
+++ src/core/ngx_palloc.h
@@ -76,10 +76,10 @@ ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);
 void ngx_destroy_pool(ngx_pool_t *pool);
 void ngx_reset_pool(ngx_pool_t *pool);
 
-void *ngx_palloc(ngx_pool_t *pool, size_t size);
-void *ngx_pnalloc(ngx_pool_t *pool, size_t size);
-void *ngx_pcalloc(ngx_pool_t *pool, size_t size);
-void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment);
+void *ngx_palloc(ngx_pool_t *pool, size_t size) __attribute__((alloc_size(2)));
+void *ngx_pnalloc(ngx_pool_t *pool, size_t size) __attribute__((alloc_size(2)));
+void *ngx_pcalloc(ngx_pool_t *pool, size_t size) __attribute__((alloc_size(2)));
+void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment) __attribute__((alloc_size(2)));
 ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);
 
 
diff --git src/core/ngx_slab.c src/core/ngx_slab.c
index b8577ce75..5836a67b0 100644
--- src/core/ngx_slab.c
+++ src/core/ngx_slab.c
@@ -44,10 +44,10 @@
 #define ngx_slab_slots(pool)                                                  \
     (ngx_slab_page_t *) ((u_char *) (pool) + sizeof(ngx_slab_pool_t))
 
-#define ngx_slab_page_type(page)   ((page)->prev & NGX_SLAB_PAGE_MASK)
+#define ngx_slab_page_type(page)   cheri_get_low_ptr_bits((page)->prev, NGX_SLAB_PAGE_MASK)
 
 #define ngx_slab_page_prev(page)                                              \
-    (ngx_slab_page_t *) ((page)->prev & ~NGX_SLAB_PAGE_MASK)
+    (ngx_slab_page_t *) cheri_clear_low_ptr_bits((page)->prev, NGX_SLAB_PAGE_MASK)
 
 #define ngx_slab_page_addr(pool, page)                                        \
     ((((page) - (pool)->pages) << ngx_pagesize_shift)                         \
@@ -184,8 +184,9 @@ void *
 ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 {
     size_t            s;
-    uintptr_t         p, m, mask, *bitmap;
-    ngx_uint_t        i, n, slot, shift, map;
+    uintptr_t         p;
+    ptraddr_t           m, mask, *bitmap, n;
+    ngx_uint_t        i, slot, shift, map;
     ngx_slab_page_t  *page, *prev, *slots;
 
     if (size > ngx_slab_max_size) {
@@ -227,7 +228,7 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 
         if (shift < ngx_slab_exact_shift) {
 
-            bitmap = (uintptr_t *) ngx_slab_page_addr(pool, page);
+            bitmap = (ptraddr_t *) ngx_slab_page_addr(pool, page);
 
             map = (ngx_pagesize >> shift) / (8 * sizeof(uintptr_t));
 
@@ -295,10 +296,10 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 
         } else { /* shift > ngx_slab_exact_shift */
 
-            mask = ((uintptr_t) 1 << (ngx_pagesize >> shift)) - 1;
+            mask = ((ptraddr_t) 1 << (ngx_pagesize >> shift)) - 1;
             mask <<= NGX_SLAB_MAP_SHIFT;
 
-            for (m = (uintptr_t) 1 << NGX_SLAB_MAP_SHIFT, i = 0;
+            for (m = (ptraddr_t) 1 << NGX_SLAB_MAP_SHIFT, i = 0;
                  m & mask;
                  m <<= 1, i++)
             {
@@ -333,7 +334,7 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 
     if (page) {
         if (shift < ngx_slab_exact_shift) {
-            bitmap = (uintptr_t *) ngx_slab_page_addr(pool, page);
+            bitmap = (ptraddr_t *) ngx_slab_page_addr(pool, page);
 
             n = (ngx_pagesize >> shift) / ((1 << shift) * 8);
 
@@ -347,7 +348,7 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
                 bitmap[i] = NGX_SLAB_BUSY;
             }
 
-            m = ((uintptr_t) 1 << ((n + 1) % (8 * sizeof(uintptr_t)))) - 1;
+            m = ((ptraddr_t) 1 << ((n + 1) % (8 * sizeof(uintptr_t)))) - 1;
             bitmap[i] = m;
 
             map = (ngx_pagesize >> shift) / (8 * sizeof(uintptr_t));
@@ -388,7 +389,7 @@ ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
 
         } else { /* shift > ngx_slab_exact_shift */
 
-            page->slab = ((uintptr_t) 1 << NGX_SLAB_MAP_SHIFT) | shift;
+            page->slab = ((ptraddr_t) 1 << NGX_SLAB_MAP_SHIFT) | shift;
             page->next = &slots[slot];
             page->prev = (uintptr_t) &slots[slot] | NGX_SLAB_BIG;
 
@@ -461,7 +462,7 @@ void
 ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
 {
     size_t            size;
-    uintptr_t         slab, m, *bitmap;
+    ptraddr_t           slab, m, *bitmap;
     ngx_uint_t        i, n, type, slot, shift, map;
     ngx_slab_page_t  *slots, *page;
 
@@ -484,15 +485,14 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
         shift = slab & NGX_SLAB_SHIFT_MASK;
         size = (size_t) 1 << shift;
 
-        if ((uintptr_t) p & (size - 1)) {
+        if ((ptraddr_t) p & (size - 1)) {
             goto wrong_chunk;
         }
 
-        n = ((uintptr_t) p & (ngx_pagesize - 1)) >> shift;
-        m = (uintptr_t) 1 << (n % (8 * sizeof(uintptr_t)));
-        n /= 8 * sizeof(uintptr_t);
-        bitmap = (uintptr_t *)
-                             ((uintptr_t) p & ~((uintptr_t) ngx_pagesize - 1));
+        n = ((ptraddr_t) p & (ngx_pagesize - 1)) >> shift;
+        m = (ptraddr_t) 1 << (n % (sizeof(uintptr_t) * 8));
+        n /= sizeof(uintptr_t) * 8;
+        bitmap = (ptraddr_t *)__builtin_align_down(p, ngx_pagesize);
 
         if (bitmap[n] & m) {
             slot = shift - pool->min_shift;
@@ -516,7 +516,7 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
             }
 
             i = n / (8 * sizeof(uintptr_t));
-            m = ((uintptr_t) 1 << (n % (8 * sizeof(uintptr_t)))) - 1;
+            m = ((ptraddr_t) 1 << (n % (8 * sizeof(uintptr_t)))) - 1;
 
             if (bitmap[i] & ~m) {
                 goto done;
@@ -541,11 +541,11 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
 
     case NGX_SLAB_EXACT:
 
-        m = (uintptr_t) 1 <<
-                (((uintptr_t) p & (ngx_pagesize - 1)) >> ngx_slab_exact_shift);
+        m = (ptraddr_t) 1 <<
+                (((ptraddr_t) p & (ngx_pagesize - 1)) >> ngx_slab_exact_shift);
         size = ngx_slab_exact_size;
 
-        if ((uintptr_t) p & (size - 1)) {
+        if ((ptraddr_t) p & (size - 1)) {
             goto wrong_chunk;
         }
 
@@ -582,11 +582,11 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
         shift = slab & NGX_SLAB_SHIFT_MASK;
         size = (size_t) 1 << shift;
 
-        if ((uintptr_t) p & (size - 1)) {
+        if ((ptraddr_t) p & (size - 1)) {
             goto wrong_chunk;
         }
 
-        m = (uintptr_t) 1 << ((((uintptr_t) p & (ngx_pagesize - 1)) >> shift)
+        m = (ptraddr_t) 1 << ((((ptraddr_t) p & (ngx_pagesize - 1)) >> shift)
                               + NGX_SLAB_MAP_SHIFT);
 
         if (slab & m) {
@@ -619,7 +619,7 @@ ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
 
     case NGX_SLAB_PAGE:
 
-        if ((uintptr_t) p & (ngx_pagesize - 1)) {
+        if ((ptraddr_t) p & (ngx_pagesize - 1)) {
             goto wrong_chunk;
         }
 
diff --git src/core/ngx_slab.h src/core/ngx_slab.h
index d1876bbec..1886c126b 100644
--- src/core/ngx_slab.h
+++ src/core/ngx_slab.h
@@ -16,7 +16,7 @@
 typedef struct ngx_slab_page_s  ngx_slab_page_t;
 
 struct ngx_slab_page_s {
-    uintptr_t         slab;
+    ptraddr_t         slab;
     ngx_slab_page_t  *next;
     uintptr_t         prev;
 };
diff --git src/event/modules/ngx_kqueue_module.c src/event/modules/ngx_kqueue_module.c
index 9c7244c45..c139864ab 100644
--- src/event/modules/ngx_kqueue_module.c
+++ src/event/modules/ngx_kqueue_module.c
@@ -345,8 +345,8 @@ ngx_kqueue_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
     ev->disabled = 0;
 
     if (ev->index < nchanges
-        && ((uintptr_t) change_list[ev->index].udata & (uintptr_t) ~1)
-            == (uintptr_t) ev)
+        && (cheri_clear_low_ptr_bits((uintptr_t) change_list[ev->index].udata, 1)
+            == (uintptr_t) ev))
     {
         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                        "kevent deleted: %d: ft:%i",
@@ -358,7 +358,7 @@ ngx_kqueue_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
 
         if (ev->index < nchanges) {
             e = (ngx_event_t *)
-                    ((uintptr_t) change_list[nchanges].udata & (uintptr_t) ~1);
+                    cheri_clear_low_ptr_bits((uintptr_t) change_list[nchanges].udata, 1);
             change_list[ev->index] = change_list[nchanges];
             e->index = ev->index;
         }
@@ -600,8 +600,8 @@ ngx_kqueue_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
         case EVFILT_READ:
         case EVFILT_WRITE:
 
-            instance = (uintptr_t) ev & 1;
-            ev = (ngx_event_t *) ((uintptr_t) ev & (uintptr_t) ~1);
+            instance = cheri_get_low_ptr_bits((uintptr_t) ev, 1);
+            ev = (ngx_event_t *) cheri_clear_low_ptr_bits((uintptr_t) ev, 1);
 
             if (ev->closed || ev->instance != instance) {
 
diff --git src/http/modules/ngx_http_log_module.c src/http/modules/ngx_http_log_module.c
index f7c4bd2f5..82717775e 100644
--- src/http/modules/ngx_http_log_module.c
+++ src/http/modules/ngx_http_log_module.c
@@ -773,11 +773,11 @@ static u_char *
 ngx_http_log_copy_short(ngx_http_request_t *r, u_char *buf,
     ngx_http_log_op_t *op)
 {
-    size_t     len;
-    uintptr_t  data;
+    size_t      len;
+    ngx_ptraddr_t data;
 
     len = op->len;
-    data = op->data;
+    data = (ngx_ptraddr_t) op->data;
 
     while (len--) {
         *buf++ = (u_char) (data & 0xff);
@@ -1722,7 +1722,7 @@ ngx_http_log_compile_format(ngx_conf_t *cf, ngx_array_t *flushes,
                 op->len = len;
                 op->getlen = NULL;
 
-                if (len <= sizeof(uintptr_t)) {
+                if (len <= sizeof(ngx_ptraddr_t)) {
                     op->run = ngx_http_log_copy_short;
                     op->data = 0;
 
diff --git src/http/modules/ngx_http_upstream_hash_module.c src/http/modules/ngx_http_upstream_hash_module.c
index e741eb237..141a9bae5 100644
--- src/http/modules/ngx_http_upstream_hash_module.c
+++ src/http/modules/ngx_http_upstream_hash_module.c
@@ -169,7 +169,7 @@ ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc, void *data)
     size_t                        size;
     uint32_t                      hash;
     ngx_int_t                     w;
-    uintptr_t                     m;
+    ptraddr_t                     m;
     ngx_uint_t                    n, p;
     ngx_http_upstream_rr_peer_t  *peer;
 
@@ -222,7 +222,7 @@ ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc, void *data)
         }
 
         n = p / (8 * sizeof(uintptr_t));
-        m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+        m = (ptraddr_t) 1 << p % (8 * sizeof(uintptr_t));
 
         if (hp->rrp.tried[n] & m) {
             goto next;
@@ -495,7 +495,7 @@ ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc, void *data)
     ngx_http_upstream_hash_peer_data_t  *hp = data;
 
     time_t                              now;
-    intptr_t                            m;
+    ptraddr_t                           m;
     ngx_str_t                          *server;
     ngx_int_t                           total;
     ngx_uint_t                          i, n, best_i;
@@ -539,7 +539,7 @@ ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc, void *data)
              peer = peer->next, i++)
         {
             n = i / (8 * sizeof(uintptr_t));
-            m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));
+            m = (ptraddr_t) 1 << i % (8 * sizeof(uintptr_t));
 
             if (hp->rrp.tried[n] & m) {
                 continue;
@@ -611,7 +611,7 @@ found:
     ngx_http_upstream_rr_peers_unlock(hp->rrp.peers);
 
     n = best_i / (8 * sizeof(uintptr_t));
-    m = (uintptr_t) 1 << best_i % (8 * sizeof(uintptr_t));
+    m = (ptraddr_t) 1 << best_i % (8 * sizeof(uintptr_t));
 
     hp->rrp.tried[n] |= m;
 
diff --git src/http/modules/ngx_http_upstream_ip_hash_module.c src/http/modules/ngx_http_upstream_ip_hash_module.c
index 1fa01d95a..996f543fd 100644
--- src/http/modules/ngx_http_upstream_ip_hash_module.c
+++ src/http/modules/ngx_http_upstream_ip_hash_module.c
@@ -152,7 +152,7 @@ ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc, void *data)
 
     time_t                        now;
     ngx_int_t                     w;
-    uintptr_t                     m;
+    ptraddr_t                     m;
     ngx_uint_t                    i, n, p, hash;
     ngx_http_upstream_rr_peer_t  *peer;
 
@@ -192,7 +192,7 @@ ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc, void *data)
         }
 
         n = p / (8 * sizeof(uintptr_t));
-        m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+        m = (ptraddr_t) 1 << p % (8 * sizeof(uintptr_t));
 
         if (iphp->rrp.tried[n] & m) {
             goto next;
diff --git src/http/modules/ngx_http_upstream_least_conn_module.c src/http/modules/ngx_http_upstream_least_conn_module.c
index ebe06276d..82dcc492f 100644
--- src/http/modules/ngx_http_upstream_least_conn_module.c
+++ src/http/modules/ngx_http_upstream_least_conn_module.c
@@ -102,7 +102,7 @@ ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
     ngx_http_upstream_rr_peer_data_t  *rrp = data;
 
     time_t                         now;
-    uintptr_t                      m;
+    ptraddr_t                      m;
     ngx_int_t                      rc, total;
     ngx_uint_t                     i, n, p, many;
     ngx_http_upstream_rr_peer_t   *peer, *best;
@@ -137,7 +137,7 @@ ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
          peer = peer->next, i++)
     {
         n = i / (8 * sizeof(uintptr_t));
-        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));
+        m = (ptraddr_t) 1 << i % (8 * sizeof(uintptr_t));
 
         if (rrp->tried[n] & m) {
             continue;
@@ -192,7 +192,7 @@ ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
              peer = peer->next, i++)
         {
             n = i / (8 * sizeof(uintptr_t));
-            m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));
+            m = (ptraddr_t) 1 << i % (8 * sizeof(uintptr_t));
 
             if (rrp->tried[n] & m) {
                 continue;
@@ -246,7 +246,7 @@ ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
     rrp->current = best;
 
     n = p / (8 * sizeof(uintptr_t));
-    m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+    m = (ptraddr_t) 1 << p % (8 * sizeof(uintptr_t));
 
     rrp->tried[n] |= m;
 
diff --git src/http/ngx_http_core_module.c src/http/ngx_http_core_module.c
index 2140e0627..3a12045e5 100644
--- src/http/ngx_http_core_module.c
+++ src/http/ngx_http_core_module.c
@@ -3419,7 +3419,7 @@ ngx_http_core_init_main_conf(ngx_conf_t *cf, void *conf)
 
 
     ngx_conf_init_uint_value(cmcf->variables_hash_max_size, 1024);
-    ngx_conf_init_uint_value(cmcf->variables_hash_bucket_size, 64);
+    ngx_conf_init_uint_value(cmcf->variables_hash_bucket_size, 128);
 
     cmcf->variables_hash_bucket_size =
                ngx_align(cmcf->variables_hash_bucket_size, ngx_cacheline_size);
@@ -3698,7 +3698,7 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
                               prev->types_hash_max_size, 1024);
 
     ngx_conf_merge_uint_value(conf->types_hash_bucket_size,
-                              prev->types_hash_bucket_size, 64);
+                              prev->types_hash_bucket_size, 128);
 
     conf->types_hash_bucket_size = ngx_align(conf->types_hash_bucket_size,
                                              ngx_cacheline_size);
diff --git src/http/ngx_http_huff_encode.c src/http/ngx_http_huff_encode.c
index c03b153da..88e0d16f1 100644
--- src/http/ngx_http_huff_encode.c
+++ src/http/ngx_http_huff_encode.c
@@ -156,7 +156,7 @@ static ngx_http_huff_encode_code_t  ngx_http_huff_encode_table_lc[256] =
 };
 
 
-#if (NGX_PTR_SIZE == 8)
+#if ((defined(__SIZEOF_SIZE_T__) && __SIZEOF_SIZE_T__ == 8) || (!defined(__SIZEOF_SIZE_T__) && NGX_PTR_SIZE == 8))
 
 #if (NGX_HAVE_LITTLE_ENDIAN)
 
diff --git src/http/ngx_http_script.c src/http/ngx_http_script.c
index a2b9f1b7b..9c10408c0 100644
--- src/http/ngx_http_script.c
+++ src/http/ngx_http_script.c
@@ -878,7 +878,7 @@ ngx_http_script_copy_code(ngx_http_script_engine_t *e)
     }
 
     e->ip += sizeof(ngx_http_script_copy_code_t)
-          + ((code->len + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));
+          + __builtin_align_up(code->len, sizeof(uintptr_t));
 
     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                    "http script copy: \"%*s\"", e->pos - p, p);
diff --git src/http/ngx_http_upstream_round_robin.c src/http/ngx_http_upstream_round_robin.c
index 1f15fae50..1a67442b7 100644
--- src/http/ngx_http_upstream_round_robin.c
+++ src/http/ngx_http_upstream_round_robin.c
@@ -282,7 +282,8 @@ ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r,
     }
 
     if (n <= 8 * sizeof(uintptr_t)) {
-        rrp->tried = &rrp->data;
+        // FIXME: this is probably wrong
+        rrp->tried = (ptraddr_t*)&rrp->data;
         rrp->data = 0;
 
     } else {
@@ -402,7 +403,8 @@ ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,
     rrp->config = 0;
 
     if (rrp->peers->number <= 8 * sizeof(uintptr_t)) {
-        rrp->tried = &rrp->data;
+        // FIXME: this is probably wrong
+        rrp->tried = (ptraddr_t*)&rrp->data;
         rrp->data = 0;
 
     } else {
@@ -522,7 +524,7 @@ static ngx_http_upstream_rr_peer_t *
 ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
 {
     time_t                        now;
-    uintptr_t                     m;
+    ptraddr_t                     m;
     ngx_int_t                     total;
     ngx_uint_t                    i, n, p;
     ngx_http_upstream_rr_peer_t  *peer, *best;
@@ -541,7 +543,7 @@ ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
          peer = peer->next, i++)
     {
         n = i / (8 * sizeof(uintptr_t));
-        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));
+        m = (ptraddr_t) 1 << i % (8 * sizeof(uintptr_t));
 
         if (rrp->tried[n] & m) {
             continue;
@@ -582,7 +584,7 @@ ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
     rrp->current = best;
 
     n = p / (8 * sizeof(uintptr_t));
-    m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
+    m = (ptraddr_t) 1 << p % (8 * sizeof(uintptr_t));
 
     rrp->tried[n] |= m;
 
diff --git src/http/ngx_http_upstream_round_robin.h src/http/ngx_http_upstream_round_robin.h
index 922ceaa04..05be35e1b 100644
--- src/http/ngx_http_upstream_round_robin.h
+++ src/http/ngx_http_upstream_round_robin.h
@@ -129,7 +129,7 @@ typedef struct {
     ngx_uint_t                      config;
     ngx_http_upstream_rr_peers_t   *peers;
     ngx_http_upstream_rr_peer_t    *current;
-    uintptr_t                      *tried;
+    ptraddr_t                      *tried;
     uintptr_t                       data;
 } ngx_http_upstream_rr_peer_data_t;
 
diff --git src/os/unix/ngx_alloc.c src/os/unix/ngx_alloc.c
index 5c2f78702..c5848e570 100644
--- src/os/unix/ngx_alloc.c
+++ src/os/unix/ngx_alloc.c
@@ -69,6 +69,9 @@ ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)
 }
 
 #elif (NGX_HAVE_MEMALIGN)
+#ifdef __CHERI_PURE_CAPABILITY__
+#error should be using posix_memalign
+#endif
 
 void *
 ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)
diff --git src/os/unix/ngx_alloc.h src/os/unix/ngx_alloc.h
index 655db257f..e38599e03 100644
--- src/os/unix/ngx_alloc.h
+++ src/os/unix/ngx_alloc.h
@@ -13,8 +13,8 @@
 #include <ngx_core.h>
 
 
-void *ngx_alloc(size_t size, ngx_log_t *log);
-void *ngx_calloc(size_t size, ngx_log_t *log);
+void *ngx_alloc(size_t size, ngx_log_t *log) __attribute__((alloc_size(1)));
+void *ngx_calloc(size_t size, ngx_log_t *log) __attribute__((alloc_size(1)));
 
 #define ngx_free          free
 
@@ -28,7 +28,7 @@ void *ngx_calloc(size_t size, ngx_log_t *log);
 
 #if (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)
 
-void *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log);
+void *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log) __attribute__((alloc_size(2)));
 
 #else
 
